%\VignetteEngine{knitr::knitr}
# nplr Vignette
### **AUTHORS**: _Frederic Commo (fredcommo@gmail.com) & Brian M. Bot_

```{r, include=FALSE, eval=TRUE}
require(nplr)
require(RCurl)
```

## Overview

This function computes a weighted n-parameters logistic regression, n from 2 to 5.  
Typical applications are drug-response or progression curve fitting.

The n-parameter logistic regression used by $nplr()$ is of the form:

$$y = B + \frac{(T - B)}{[1 + 10^{b.(xmid - x)}]^s}$$

Where $B$ and $T$ are the bottom and top asymptotes, respectively, $b$ and $xmid$ are the Hill slope and the x-coordinate at the inflexion point, respectively, and $s$ is an asymetric coefficient. This equation is sometimes refered to as a 5-parameter logistic regression, or the Richards equation.  
The $npars$ argument allows a user to run simplest models, while the default value $npars = "all"$ asks the function to test which model fits the best the data, with respect to a weighted Goodness-of-Fit estimator. See the $nplr$ documentation for more details.

In a drug-response (or progression) curve fitting context, typical needs are to invert the function in order to estimate the x-value, e.g. an IC50, given a y-value (the 0.5 survival rate). To do so, the implemented $predict()$ method takes 2 arguments: the built model (an instance of the class nplr), and one (or a vector of) target(s), and returns the corresponding x-values and their 95% confidence intervals.

The $nplr()$ function has been optimized for fitting curves on y-values passed as proportions, from 0 to 1. If data are provided as original response values, e.g. optic density measurements, the $convertToProp()$ function may be helpful. For some curve fitting, the x-values may need to be log-transformed, e.g. drug concentrations. In such case, using $useLog=TRUE$ in $nplr()$ applies a $Log_10$ transformation on the x-values. Other arguments are described in the $nplr$ documentation.

A specific $plot()$ function has been implemented in order to visualize the results.

Several self-explanatory $get$ functions give an easy access to the results stored in the $nplr()$ output.


```{r}
sessionInfo()
```

```{r, simpleExample, fig.align='center', fig.width=9}
# A simple example: drug-response fitting without replicates
url <- getURL("https://raw.github.com/fredcommo/IC50new/master/demo_files/demo1.tsv")
dat <- read.delim(text=url)
np1 <- nplr(dat$x, dat$y)
plot(np1)
getAUC(np1)
getEstimates(np1)
```

```{r, duplicates, fig.align='center', fig.width=9}
# Here a similar example, with replicated measurements
url <- getURL("https://raw.github.com/fredcommo/IC50new/master/demo_files/demo2.tsv")
dat <- read.delim(text=url)
np2 <- nplr(dat$x, dat$y)
plot(np2)
getAUC(np2)
getEstimates(np2)
```

```{r, progressCurve, fig.align='center', fig.width=9}
# An example of progression curve fitting
# where the x-values Log10 transformation is not required
# and the y-values are in some arbitrary scale.
url <- getURL("https://raw.github.com/fredcommo/IC50new/master/demo_files/demo4.tsv")
dat <- read.delim(text=url)

# convert the y-values to proportions
x <- dat$x
yp <- convertToProp(dat$y, 5, 110)
np3 <- nplr(x, yp, useLog=FALSE)
plot(np3, showTarget=FALSE, xlab="Time (hrs)", ylab="Progression")
getInflexion(np3)
```

```{r, nparsEffect, fig.align='center', fig.width=9}
# On the same data: how the number of parameters can affect the fitting
url <- getURL("https://raw.github.com/fredcommo/IC50new/master/demo_files/demo4.tsv")
dat <- read.delim(text=url)

# convert the y-values to proportions
x <- dat$x
yp <- convertToProp(dat$y, 5, 110)
models <- lapply(2:5, function(p){
  tmp <- nplr(x, yp, useLog=FALSE, npars=p)
  list(x=getXcurve(tmp), y=getYcurve(tmp), infp=getInflexion(tmp), gof=getGoodness(tmp))
  })

plot(x, yp, col="grey", pch=19, cex=1.25)
for(i in 1:length(models)) {
  tmp <- models[[i]]
  lines(tmp$x, tmp$y, lwd=5, col=i)
  points(tmp$infp, pch=19, col=i, cex=2)
  legend(0, 1-i/10, legend=sprintf("%s-par: gof=%s", i+1, round(tmp$gof, 3)), lwd=2, col=i, bty="n")
  }
```
